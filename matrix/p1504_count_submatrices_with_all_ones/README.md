### Attempt 1 (Failure, F01)
This problem was the daily after p1277 (count square submatrices with all ones), so I tried to solve it in a similar way using dynamic programming. I created another matrix whose elements would track the number of valid submatrices with all ones. I spent a bit of time writing down my thoughts and drawing a few diagrams in order to work out the logic of how to keep track of and update the value for each element in the my represented_rectangles matrix (`rep_rects`) as I traversed the input matrix by rows and cols. My initial two ideas that helped the most were that each 1 element would represent at least itself, as well as the `M`x1 and 1x`N` rectangles where `M` and `N` were the consecutive 1's to left and right of the current element respectively, thinking about it in terms of each 1 element "extending" some amount of rectangles. 

The second idea was that in order to extend larger rectangles having a side greater than 1, it was necessary to look at the element up and to the left of the current, at $(row-1,col-1)$. I also cared about the consecutive runs of 1 to the left and right of that element, as then our current element would extend even more rectangles leftwards and upwards, beyond just the 2x2 square being looked at (assuming `mat[row-1][col-1] != 0`), and that the number of rectangles that our current element would extend would be limited by both its own run of leftward/upward 1's as well as the the similar runs of the up-left element. This would mean that I would need to backtrack up-left even further to extend larger and larger rectangles.

I devised some algorithms in order to calculate how many new rectangles `rep_rects[r][c]` would accumulate for each step up-left, and to keep track of the maximum number of rectangles that could possibly be added at each step based on the maximum length of leftward/upward runs of 1's from each of the previous elements diagonal to `rep_rects[r][c]`. I iterated on this program for a couple hours, trying to solve for edge cases and adding new test cases that I could get to work, but still finding myself without a complete solution. At this point I had put off dinner for a while and decided to give it a rest, look at some explanations of the solution, and give it another pass on a later date.

### Comments on Solutions
After looking at explanations, it seemed that I was onto the right idea by tracking the run of 1's for a given element, but the explanations I found only tracked the runs from the left. A second matrix tracking leftward runs is created and filled. Then, to find the number of subrectangles that their `rep_rects[r][c]` would represent, they would search their `leftward_run_length[][]` matrix up the current column, incrementing the value of  `rep_rects[r][c]` by the length of the minimum of the length of the run `leftward_run_length[r][c-dist]`, and a value `current`, which would begin equal to `leftward_run_length[r][c-dist]` and continously be updated to be the minimum of itself and `leftward_run_length[r][c-dist]`, in the same way that I realized that I would need to constrain my program. Many comments were made about this problems similarity to the Largest Histogram problem, which I have yet to see.

Overall, I think I had a lot of good ideas solving this problem, but my implementation was complex and somewhat sloppy compared to more ideal solutions. I will return to this problem another time, and will likely try to implement the concept of a monotonic stack, which keeps track of the nearest smaller column to any given column, allowing us to skip some processing and increment `rep_rects[r][j]` a bit more intuitively.
